<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Document</title>
  <style>
    canvas {
      user-select: none;
      position: absolute;
    }
    #stage {
      width: 480px;
      height: 320px;
      position: relative;
    }
    #background-layer { z-index: 1 }
    #buff-layer { z-index: 2 }
    #playground { z-index: 3 }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="background-layer"></canvas>
    <canvas id="buff-layer"></canvas>
    <canvas id="playground"></canvas>
  </div>
  <button onclick="game.clear()">clear</button>
  <script>
    function Position (x, y) {
      this.x = x; this.y = y;
    }

    Position.prototype.set = function (x, y) {
      this.x = x; this.y = y;
    }

    Position.prototype.get = function () {
      return [this.x, this.y]
    }
  </script>
  <script>
    function Chequer (ctx, position, lattice) {
      this.ctx = ctx
      this.lattice = lattice
      this.position = position
      this.selected = false
      this.heart = new Position(
        this.position.x +  this.lattice.size / 2,
        this.position.y +  this.lattice.size / 2
      )
      this.render()
    }

    Chequer.prototype.toggleSelect = function (selected) {
      if (typeof selected === 'boolean') {
        this.selected = selected
      } else {
        this.selected = !this.selected
      }
      this.render()
    }

    Chequer.prototype.render = function () {
      this.clear()
      this.ctx.beginPath()
      const heart = this.heart
      this.ctx.arc(heart.x, heart.y, Chequer.radius, 0, Math.PI * 2, true);
      if (this.selected) {
        this.ctx.fill()
      } else {
        this.ctx.stroke()
      }

      const r = Chequer.radius * 0.618
      this.ctx.beginPath()
      this.ctx.save()
      this.ctx.fillStyle = this.selected ? '#fff' : '#000'
      this.ctx.arc(heart.x, heart.y, r, 0, Math.PI * 2, true)
      this.ctx.fill()
      this.ctx.restore()
    }

    Chequer.prototype.clear = function () {
      const lineWidth = this.ctx.lineWidth
      const diameter = Chequer.radius * 2 + 2 * lineWidth
      this.ctx.clearRect(this.heart.x - Chequer.radius - lineWidth, this.heart.y - Chequer.radius - lineWidth, diameter, diameter)
      this.ctx.beginPath()
    }

    Chequer.radius = 10
  </script>
  <script>
    function Lattice (ctx, position) {
      const size = Chequer.radius * 2 + Lattice.padding
      this.ctx = ctx
      this.size = size

      position.x *= size
      position.y *= size
      this.position = position
      this.selected = false
    }

    Lattice.prototype.clear = function () {
      this.ctx.clearRect(this.position.x, this.position.y, this.size, this.size)
    }

    Lattice.padding = 10
    Lattice.lineWidth = 1

    function ChequerLattice (ctx, position, playgroundCtx) {
      Lattice.call(this, ctx, position)
      this.chequer = new Chequer(playgroundCtx, position, this)
      this.render()
    }

    ChequerLattice.prototype.render = function () {
      const { ctx, position, size } = this
      ctx.beginPath()
      ctx.rect(position.x, position.y, size, size)
      ctx.stroke()
    }

    // 玩法 全部棋子摆满后，取出中央的一颗。棋子只能横向纵向(不可斜向)跳过邻的棋子到空位上。被跳过的棋子即被吃掉。
    // 按照前面的方法继续移动，直到最后走不下去了，数数还剩下几颗棋子。剩下的棋子越少越厉害。
    ChequerLattice.prototype.selectedBuff = function () {

    }

    ChequerLattice.prototype.toggleSelect = function (selected) {
      if (typeof selected === 'boolean') {
        this.selected = selected
      } else {
        this.selected = !this.selected
      }
      this.chequer.toggleSelect(selected)
    }

    ChequerLattice.prototype.clear = function () {
      //
    }

    function extend (targetCtor, ...sourceCtors) {
      for (var i = 0; i < sourceCtors.length; i++) {
        const sourceCtor = sourceCtors[i];
        const oldPrototype = sourceCtor.prototype
        sourceCtor.prototype = Object.assign(Object.create(targetCtor.prototype), oldPrototype)
        sourceCtor.prototype.constructor = sourceCtor
      }
    }
    extend(Lattice, ChequerLattice)

    function Chessboard (ctx) {
      const size = (Chequer.radius * 2 + Lattice.padding * 2) * 7 + 8 * Lattice.lineWidth
      this.size = size
      this.ctx = ctx
    }

    Chessboard.prototype.create = function () {
      ctx.beginPath()

      ctx.rect(0, 0, this.size, this.size);

      ctx.stroke()
    }
  </script>
  <script>
     function Game () {
      this.chessboard = this.createBroad()
      this.latticeSize = 7
      this.lattices = new Array(this.latticeSize).fill().map(v => new Array(this.latticeSize).fill(null))
      this.selectedLattice = null
      this.mousedownHandler = null
      this.mousemoveHandler = null
      this.mouseupHandler = null
      this.bgCtx = null
      this.playgroundCtx = null
      this.buffCtx = null
    }

    Game.prototype.init = function () {
      this.selectedChequer = null
      this.initHandlers()
      this.reset()
      return this
    }

    Game.prototype.initHandlers = function () {
      this.mousedownHandler = this.mousedown.bind(this)
      this.mousemoveHandler = this.mousemove.bind(this)
      this.mouseupHandler = this.mouseup.bind(this)
      const canvas = document.getElementById('playground')

      canvas.addEventListener('mousedown', this.mousedownHandler)
      canvas.addEventListener('mousemove', this.mousemoveHandler)
      canvas.addEventListener('mouseup', this.mouseupHandler)
    }

    Game.prototype.reset = function () {
      this.resetBackgroundLayer()
      this.resetBuffLayer()
      this.resetPlayground()
    }

    Game.prototype.resetBackgroundLayer = function () {
      const canvas = document.getElementById('background-layer')
      this.bgCtx= canvas.getContext('2d')
      canvas.width = this.chessboard.size
      canvas.height = this.chessboard.size
    }

    Game.prototype.resetBuffLayer = function () {
      const canvas = document.getElementById('buff-layer')
      this.buffCtx= canvas.getContext('2d')
      canvas.width = this.chessboard.size
      canvas.height = this.chessboard.size
    }

    Game.prototype.resetPlayground = function () {
      const canvas = document.getElementById('playground')
      canvas.width = this.chessboard.size
      canvas.height = this.chessboard.size

      const bgCtx = this.bgCtx
      this.playgroundCtx = canvas.getContext('2d')
      // this.playgroundCtx.fillStyle = 'rgba(255, 255, 255, 0)';

      for (let i = 0 ; i < this.latticeSize; i++) {
        for (let j = 0 ; j < this.latticeSize; j++) {
          const position = new Position(i, j)
          if (
            ((i < 2 || i > 4) && j < 2) ||
            ((i < 2 || i > 4) && j > 4)
          ) {
            continue
          }

          if (i === 3 && j === 3) {
            this.lattices[i][j] = new Lattice(bgCtx, position)
          } else {
            this.lattices[i][j] = new ChequerLattice(bgCtx, position, this.playgroundCtx)
          }
        }
      }
    }

    Game.prototype.createBroad = function () {
      const canvas = document.getElementById('background-layer')
      const ctx = canvas.getContext('2d')
      this.ctx = ctx
      return new Chessboard(ctx)
    }

    Game.prototype.clear = function () {
      this.lattices.flat().forEach(lattice => lattice.chequer?.clear())
    }

    Game.prototype.toggleSelect = function (lattice, isSelected) {
      lattice.toggleSelect(isSelected)
    }

    Game.prototype.mousedown = function (e) {
      const { offsetX, offsetY } = e
      rowsLoop:
      for (let i = 0; i < this.lattices.length; i++) {
        const rows = this.lattices[i]
        colsLoop:
        for (let j = 0 ; j < rows.length; j++) {
          const lattice = rows[j]
          // 非格子 非棋子
          if (!lattice || !lattice.chequer) {
            continue
          }

          // 是否点击棋子
          const chequer = lattice.chequer
          const heart = chequer.heart
          if ((heart.x - offsetX) ** 2 + (heart.y - offsetY) ** 2 < Chequer.radius**2) {
            if (this.selectedLattice === lattice && lattice.selected) {
              this.toggleSelect(this.selectedLattice, false)
              this.selectedLattice = null
              break
            }

            if (this.selectedLattice) {
              this.toggleSelect(this.selectedLattice, false)
            }

            this.toggleSelect(lattice, true)
            this.selectedLattice = lattice
            break rowsLoop
          }
        }
      }
    }

    Game.prototype.mousemove = function () {}
    Game.prototype.mouseup = function () {}

    Game.prototype.destroy = function () {}

    const game = new Game().init()
  </script>
</body>
</html>